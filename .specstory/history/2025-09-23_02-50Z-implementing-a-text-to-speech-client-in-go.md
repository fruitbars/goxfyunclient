<!-- Generated by SpecStory -->

# Implementing a text-to-speech client in Go (2025-09-23 02:50Z)

_**User (2025-09-23 02:50Z)**_

@tts/ 

参考下官方的demo，仔细审视下tts的实现

package xfyun

import (
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"strings"
	"time"
	"tuling2asesln/pkg/utils"

	"github.com/gorilla/websocket"
)

const (
	host        = "tts-api.xfyun.cn"
	apiEndpoint = "/v2/tts"
)

// TTSClient holds the configuration for the Text-to-Speech client.
type TTSClient struct {
	AppID     string
	APIKey    string
	APISecret string
	conn      *websocket.Conn
}

// requestPayload defines the structure for the request sent to the TTS service.
type requestPayload struct {
	Common   requestCommon   `json:"common"`
	Business requestBusiness `json:"business"`
	Data     requestData     `json:"data"`
}

type requestCommon struct {
	AppID string `json:"app_id"`
}

type requestBusiness struct {
	AUE string `json:"aue"` // Audio encoding
	AUF string `json:"auf"` // Audio format
	VCN string `json:"vcn"` // Voice name
	TTE string `json:"tte"` // Text encoding
}

type requestData struct {
	Status int    `json:"status"` // 0 for first frame, 1 for middle, 2 for last
	Text   string `json:"text"`   // Base64 encoded text
}

// serverResponse defines the structure for the response received from the TTS service.
type serverResponse struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
	SID     string `json:"sid"`
	Data    struct {
		Audio  string `json:"audio"`  // Base64 encoded audio data
		Status int    `json:"status"` // 2 indicates the final result
		CED    string `json:"ced"`
	} `json:"data"`
}

// NewTTSClient creates a new client for the TTS service.
func NewTTSClient(appID, apiKey, apiSecret string) *TTSClient {
	return &TTSClient{
		AppID:     appID,
		APIKey:    apiKey,
		APISecret: apiSecret,
	}
}

// Connect establishes a WebSocket connection to the TTS service.
func (c *TTSClient) Connect() error {
	if c.AppID == "" || c.APIKey == "" || c.APISecret == "" || strings.TrimSpace(c.AppID) == "" {
		return fmt.Errorf("AppID, APIKey, or APISecret is not configured")
	}

	authURL, err := c.buildAuthURL()
	log.Println(authURL)
	if err != nil {
		log.Println(err)
		return fmt.Errorf("could not build auth url: %w", err)
	}

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	conn, resp, err := websocket.DefaultDialer.DialContext(ctx, authURL, nil)
	if err != nil {
		log.Println(err)

		bodyBytes, readBodyErr := io.ReadAll(resp.Body)
		if readBodyErr != nil {
			log.Println(readBodyErr)
			return err
		} else {
			respBodyShort := utils.SafeSnippet(bodyBytes, 512)
			// 检查 HTTP 响应
			if resp != nil {
				log.Printf("WebSocket handshake response: status=%s, headers=%v, body=%s\n", resp.Status, resp.Header, respBodyShort)
				// 如果需要，可以进一步处理 resp.Body 或其他字段
			}

			return fmt.Errorf("websocket dial failed: %w,status=%s, body=%s", err, resp.Status, respBodyShort)
		}
	}

	c.conn = conn
	return nil
}

// Close closes the WebSocket connection.
func (c *TTSClient) Close() {
	if c.conn != nil {
		c.conn.Close()
	}
}

// buildAuthURL generates the authenticated WebSocket URL.
func (c *TTSClient) buildAuthURL() (string, error) {
	ul, err := url.Parse("https://" + host + apiEndpoint)
	if err != nil {
		return "", err
	}
	date := time.Now().UTC().Format(http.TimeFormat)
	signatureOrigin := fmt.Sprintf("host: %s\ndate: %s\nGET %s HTTP/1.1", "ws-api.xfyun.cn", date, ul.Path)

	mac := hmac.New(sha256.New, []byte(c.APISecret))
	mac.Write([]byte(signatureOrigin))
	signature := base64.StdEncoding.EncodeToString(mac.Sum(nil))

	authOrigin := fmt.Sprintf(`api_key="%s", algorithm="hmac-sha256", headers="host date request-line", signature="%s"`, c.APIKey, signature)
	auth := base64.StdEncoding.EncodeToString([]byte(authOrigin))

	v := url.Values{}
	v.Add("authorization", auth)
	v.Add("date", date)
	v.Add("host", "ws-api.xfyun.cn")

	return "wss://" + host + apiEndpoint + "?" + v.Encode(), nil
}

// SendText sends a chunk of text to be synthesized.
func (c *TTSClient) SendText(text string, isLast bool) error {
	if c.conn == nil {
		return fmt.Errorf("websocket connection is not established")
	}

	status := 1
	if isLast {
		status = 2
	}

	payload := requestPayload{
		Common: requestCommon{AppID: c.AppID},
		Business: requestBusiness{
			AUE: "raw", // raw = pcm
			AUF: "audio/L16;rate=16000",
			VCN: "x4_yezi",
			TTE: "UTF8",
		},
		Data: requestData{
			Status: status,
			Text:   base64.StdEncoding.EncodeToString([]byte(text)),
		},
	}
	return c.conn.WriteJSON(payload)
}

// ReceiveAudio receives audio data from the WebSocket connection.
// It returns the audio data, a flag indicating if it's the last frame, and any error.
func (c *TTSClient) ReceiveAudio() ([]byte, bool, error) {
	if c.conn == nil {
		return nil, false, fmt.Errorf("websocket connection is not established")
	}

	_, message, err := c.conn.ReadMessage()
	if err != nil {
		if websocket.IsCloseError(err, websocket.CloseNormalClosure) {
			return nil, true, nil // Clean close
		}
		return nil, false, fmt.Errorf("error reading message: %w", err)
	}

	var resp serverResponse
	if err := json.Unmarshal(message, &resp); err != nil {
		log.Printf("Error unmarshalling server response: %v", err)
		return nil, false, err
	}

	if resp.Code != 0 {
		return nil, false, fmt.Errorf("server error: code=%d, message=%s, sid=%s", resp.Code, resp.Message, resp.SID)
	}

	audioData, err := base64.StdEncoding.DecodeString(resp.Data.Audio)
	if err != nil {
		log.Printf("Error decoding audio data: %v", err)
		return nil, false, err
	}

	isLast := resp.Data.Status == 2
	return audioData, isLast, nil
}


---

_**Assistant**_

<think><details><summary>Thought Process</summary>**Analyzing TTS Implementations**

I'm currently comparing the user's `TTSClient` implementation with the demo code. So far, the provided code seems self-contained and well-structured. I'm diving into the nuances of how they handle audio streaming and error management, looking for performance bottlenecks.


**Dissecting Authentication Methods**

I'm now digging into the authentication flow. The user's implementation constructs the authorization header manually, while my code uses a helper. I'm checking how each method generates the signature and URL, comparing them for robustness and potential vulnerabilities. A key focus is understanding the differences in handling API secrets securely.


**Scrutinizing Authentication Details**

I'm now comparing the user's `buildAuthURL` function with my `auth.AssembleAuthURLWithHostPath`. My code uses a different host ("ws-api.xfyun.cn") than the user's ("tts-api.xfyun.cn"). This is the initial area of investigation. I'm parsing how they handle timestamps and signatures to ensure accurate request signing and thus successful authentication. Then checking how they handle the headers, and how the request is built.


**Evaluating Authentication Method Discrepancies**

I'm now meticulously comparing the user's `buildAuthURL` with my `auth.AssembleAuthURLWithHostPath`, focusing on their differing use of "tts-api.xfyun.cn" versus "ws-api.xfyun.cn". Analyzing the demo code reveals an apparent inconsistency in their host usage, which could affect authentication. The use of `GET` in the demo code's signature origin, while other XFYUN services use `POST`, is also a key point of investigation.


**Investigating HTTP Method Differences**

I'm now poring over the `docs/tts.md` documentation to clarify the correct HTTP method for the signature generation. The discrepancy between the user's `buildAuthURL`'s use of `GET` and my `POST` implementation needs validation. I'm confirming whether my existing code aligns with XFYUN's official recommendations.


**Confirming HTTP Method Choice**

I've now compared the user's `buildAuthURL` implementation, which uses `GET`, to my code's `POST` method. I'm consulting `docs/tts.md` for definitive guidance on the correct HTTP method for the signature. The demo code's use of GET, while my existing code uses POST, warrants verification against official documentation.


**Validating Method Selection**

I'm now comparing my code with the user's example, noting differences. Specifically, I'm focused on the HTTP method used for authentication. The user's demo uses `GET`, whereas my code currently uses `POST`. I'm referencing `docs/tts.md` for authoritative guidance to resolve this critical discrepancy.


**Synthesizing Implementation Comparison**

I'm currently assimilating the findings from comparing the user's and my `TTSClient` implementations. A key difference is the HTTP method used for signature generation; the user's demo utilizes `GET`, while my code uses `POST`. I am now analyzing the official documentation to definitively resolve this critical divergence.


**Examining Implementation Discrepancies**

I'm now meticulously comparing the user's demo code and mine, focusing on the different methods employed for signature generation. The key difference lies in the HTTP method: the user's demo uses `GET`, while my code leverages `POST`. To resolve this, I'm consulting `docs/tts.md` for definitive guidance, which will dictate necessary adjustments to my implementation.


**Reviewing Code Structure**

I'm now focusing on the overall structure. The demo code's clear organization aids comprehension. I've noted the key components: the `TTSClient`, authentication, and streaming logic. Comparing this with my code, I'm assessing alignment, specifically how my `TTSClient` mirrors the demo and its handling of authentication, request construction, and audio data transmission.


**Reviewing Code Refinements**

I'm now reviewing the demo code and my own implementation of `TTSClient`, concentrating on the authentication flow. The user's code uses `GET` for the signature's HTTP method, while I use `POST`. I'm consulting `docs/tts.md` to determine which is correct, and if necessary, I'll adapt my code to match. The key focus is understanding the difference.


**Assessing Method Consistency**

I'm now examining the `docs/tts.md` documentation to definitively resolve the discrepancy in HTTP method selection: the user's code's `GET` versus my code's `POST`. After that, I'll address the potential nil-pointer dereference in the `Connect` and `TextToSpeech` methods. The demo uses the `GET` method which may lead to inconsistencies.


**Examining Authentication Flow**

I'm now analyzing the authentication flow and reviewing the `Connect` method, specifically the URL generation. The demo hardcodes the host as "tts-api.xfyun.cn", but my implementation uses "ws-api.xfyun.cn". The documentation in `docs/tts.md` is my next step, to ensure the correct API endpoint and host usage for successful authentication.


</details></think>

---

好的，我们来一起审视一下`tts`的实现。

我将首先分析您提供的官方demo，然后与我们项目中现有的`tts`代码进行对比，找出其中的差异和潜在问题，并进行修复。

我先来分析一下现有的认证逻辑。

---

Read file: undefined

---

<think><details><summary>Thought Process</summary>**Evaluating Implementation Details**

I've finished reviewing the `tts` implementation, focusing on the date format usage. I noted the discrepancy between `time.RFC1123` and the demo's `http.TimeFormat`. This needs further examination. I'll evaluate the impact of that difference, checking for any potential interoperability issues.


**Verifying Method Specification**

I've reviewed the `auth.go` and `tts/client.go` implementations. The demo uses "GET" in the signature, while my code uses "POST." I need to determine which is correct for the TTS service. I'm now consulting the official documentation, specifically `docs/tts_api_protocol.md`, to verify the expected HTTP method for authentication.


</details></think>

---

Okay, I've reviewed the authentication logic in `internal/auth/auth.go`. The implementation seems solid, but it uses `time.RFC1123`, while the demo uses `http.TimeFormat`, which is functionally identical. The key difference remains the HTTP method used in the signature string (`POST` in my code, `GET` in the demo).

To resolve this, I'll now examine `docs/tts_api_protocol.md` to determine the correct method required by the API. This will also help clarify if the `AUF` parameter is required in the `TextToSpeech` method.

---

Read file: undefined

---

<think><details><summary>Thought Process</summary>**Examining the Protocol**

I've been reviewing the `tts` implementation, and just finished reading the documentation at `docs/tts_api_protocol.md`. Key findings include the endpoint `wss://tts-api.xfyun.cn/v2/tts` and the use of a WebSocket connection. I'm starting to sketch out how my code will interact with the API based on the protocol's specifications.


**Verifying Endpoint Host**

I've identified a crucial discrepancy and a subtle detail. The documentation states the endpoint is `tts-api.xfyun.cn`, while my code uses `ws-api.xfyun.cn`. The signature and `host` parameter, however, correctly use `ws-api.xfyun.cn`. I'll update my code to align the connection host and ensure my implementation adheres to this nuanced detail, paying close attention to the distinction.


**Dissecting Auth and Host**

I've got a much clearer picture now, focusing on how I handle authentication and the API host. My current `AssembleAuthURLWithHostPath` function uses the same host for both the connection URL and the signature, which is incorrect here. The user's demo has the right approach. The `host` in the signature and the URL's host are different. I need to adjust my code, so I pass `tts-api.xfyun.cn` for the connection but `ws-api.xfyun.cn` for signature generation.


**Adapting Authentication Logic**

I've decided to move forward with implementing a custom authentication URL builder, mirroring the user's demo. My goal is to correctly handle the distinct host requirements for the WebSocket connection and the signature generation within the `tts/client.go` file. This will prevent my generic authentication function from creating incorrect requests, as this API requires a unique approach. Also I will change request method to `GET`.


**Adjusting the Implementation**

I'm now focusing on the core fixes. I'll change the endpoint host to `tts-api.xfyun.cn` and add a separate constant for signature generation: `ws-api.xfyun.cn`. I'm abandoning the generic auth and will implement a custom authentication URL builder within the `tts/client.go` file, ensuring `GET` requests and correcting the `auf` parameter when needed. Also I will address the error handling for the websocket dial.


**Planning the Code Changes**

I'm now starting the implementation phase. I'm focusing on editing `tts/client.go` based on my analysis of the API protocol and the discrepancies I've identified. My immediate goals are to modify the endpoint host, implement a custom authentication URL builder using the user's pattern, correct the HTTP method, and address the `auf` parameter and WebSocket dial errors. The code edits will align with my previously-stated plan to address these crucial issues.


**Finalizing Implementation Steps**

I'm now reviewing my plan and confirming the implementation steps. I will change the `APIHost` constant in `tts/client.go` to `tts-api.xfyun.cn`. I will create an `AuthHost` constant, holding the value `ws-api.xfyun.cn`, for signature generation. I will implement `buildAuthURL`, replace the `AssembleAuthURLWithHostPath` calls. Finally, I'll update the error handling of `Connect` and `TextToSpeech`, and also modify the `sendRequest` function to include the `auf` parameter when necessary, as laid out in my plan.


</details></think>

---

好的，我已经仔细审阅了您提供的官方 Demo 以及讯飞 TTS 的 API 协议文档，发现当前 `goxfyunclient` 中的 `tts` 服务实现确实存在一些与官方要求不符之处。

核心问题主要集中在**鉴权流程**和**请求参数**上。

1.  **鉴权 Host 不一致**：API 文档明确指出，建立 WebSocket 连接的域名是 `tts-api.xfyun.cn`，而参与鉴权签名的 `host` 字段必须固定为 `ws-api.xfyun.cn`。我当前的代码混用了这两个地址。
2.  **鉴权方法错误**：在生成签名时，我错误地使用了 `POST` 方法，而文档规定必须使用 `GET`。
3.  **请求参数缺失**：在非流式的 `TextToSpeech` 方法中，当音频格式 (`aue`) 设置为 `raw` (PCM) 时，我遗漏了配套的 `auf` 参数（用于指定采样率等信息），这是一个潜在的 bug。
4.  **连接错误处理**：在处理 WebSocket 连接失败的情况时，代码存在潜在的空指针风险，并且在 `TextToSpeech` 方法中没有充分利用和记录失败时的响应信息，不利于调试。

接下来，我将根据以上分析，对 `internal/service/tts/client.go` 文件进行一系列修正。这包括：

*   修正连接和鉴权使用的主机名。
*   重写鉴权 URL 的生成逻辑，确保使用 `GET` 方法并遵循官方的 host 规则。
*   修复 `TextToSpeech` 方法中的参数缺失问题。
*   改进 WebSocket 连接建立时的错误处理逻辑，使其更健壮。

我这就开始修改代码。

---

<details><summary>Edit file: internal/service/tts/client.go</summary>

undefined

**Chunk 1**
Lines added: 2, lines removed: undefined

```diff
@@ -3,4 +3,6 @@
  import (
  	"context"
+ 	"crypto/hmac"
+ 	"crypto/sha256"
  	"encoding/base64"
  	"encoding/json"
```

**Chunk 2**
Lines added: 1, lines removed: undefined

```diff
@@ -12,4 +14,5 @@
  	"log/slog"
  	"net/http"
+ 	"net/url"
  	"strings"
  	"time"
```

**Chunk 3**
Lines added: 2, lines removed: 1

```diff
@@ -19,5 +22,6 @@
  
  const (
- 	APIHost     = "ws-api.xfyun.cn"
+ 	APIHost     = "tts-api.xfyun.cn"
+ 	AuthHost    = "ws-api.xfyun.cn"
  	APIEndpoint = "/v2/tts"
  	Scheme      = "wss"
```

**Chunk 4**
Lines added: 1, lines removed: 1

```diff
@@ -70,5 +74,5 @@
  	}
  
- 	authURL, err := auth.AssembleAuthURLWithHostPath(Scheme, APIHost, APIEndpoint, "POST", c.APIKey, c.APISecret)
+ 	authURL, err := c.buildAuthURL()
  	c.Logger.Debug("connecting to tts websocket", "url", authURL)
  	if err != nil {
```

**Chunk 5**
Lines added: 10, lines removed: 12

```diff
@@ -83,18 +87,16 @@
  		c.Logger.Error("websocket dial failed", "url", authURL, "error", err)
  
- 		bodyBytes, readBodyErr := io.ReadAll(resp.Body)
- 		if readBodyErr != nil {
- 			c.Logger.Error("failed to read response body", "error", readBodyErr)
- 			return err
- 		} else {
+ 		if resp != nil {
+ 			bodyBytes, readBodyErr := io.ReadAll(resp.Body)
+ 			if readBodyErr != nil {
+ 				c.Logger.Error("failed to read response body", "error", readBodyErr)
+ 				return err // 返回原始的拨号错误
+ 			}
  			respBodyShort := utils.SafeSnippet(bodyBytes, 512)
- 			// 检查 HTTP 响应
- 			if resp != nil {
- 				c.Logger.Debug("WebSocket handshake response", "status", resp.Status, "headers", resp.Header, "body", respBodyShort)
- 				// 如果需要，可以进一步处理 resp.Body 或其他字段
- 			}
- 
- 			return fmt.Errorf("websocket dial failed: %w,status=%s, body=%s", err, resp.Status, respBodyShort)
+ 			c.Logger.Debug("WebSocket handshake response", "status", resp.Status, "headers", resp.Header, "body", respBodyShort)
+ 			return fmt.Errorf("websocket dial failed: %w, status=%s, body=%s", err, resp.Status, respBodyShort)
  		}
+ 
+ 		return fmt.Errorf("websocket dial failed: %w", err)
  	}
  	c.Logger.Info("tts websocket connection established")
```

**Chunk 6**
Lines added: 1, lines removed: 1

```diff
@@ -180,5 +182,5 @@
  
  func (c *TTSClient) TextToSpeech(ctx context.Context, text, voiceName, audioFormat string) ([]byte, error) {
- 	authURL, err := auth.AssembleAuthURLWithHostPath(Scheme, APIHost, APIEndpoint, "POST", c.APIKey, c.APISecret)
+ 	authURL, err := c.buildAuthURL()
  
  	if err != nil {
```

**Chunk 7**
Lines added: 9, lines removed: 1

```diff
@@ -187,7 +189,15 @@
  
  	c.Logger.Debug("connecting to tts websocket", "url", authURL)
- 	conn, _, err := websocket.DefaultDialer.Dial(authURL, nil)
+ 	conn, resp, err := websocket.DefaultDialer.Dial(authURL, nil)
  	if err != nil {
  		c.Logger.Error("websocket dial failed", "url", authURL, "error", err)
+ 		if resp != nil {
+ 			bodyBytes, readBodyErr := io.ReadAll(resp.Body)
+ 			if readBodyErr != nil {
+ 				c.Logger.Error("failed to read response body", "error", readBodyErr)
+ 			} else {
+ 				c.Logger.Error("websocket dial response body", "body", utils.SafeSnippet(bodyBytes, 512))
+ 			}
+ 		}
  		return nil, fmt.Errorf("WebSocket连接失败: %w", err)
  	}
```

**Chunk 8**
Lines added: 7, lines removed: 2

```diff
@@ -212,8 +222,13 @@
  
  func (c *TTSClient) sendRequest(conn *websocket.Conn, text, voiceName, audioFormat string) error {
+ 	business := models.RequestBusiness{AUE: audioFormat, VCN: voiceName, TTE: "UTF8"}
+ 	if audioFormat == "raw" {
+ 		business.AUF = "audio/L16;rate=16000"
+ 	}
+ 
  	req := &models.RequestPayload{
  		Common:   models.RequestCommon{AppID: c.AppID},
- 		Business: models.RequestBusiness{AUE: audioFormat, VCN: voiceName, TTE: "UTF8"},
- 		Data:     models.RequestData{Status: 2, Text: text},
+ 		Business: business,
+ 		Data:     models.RequestData{Status: 2, Text: base64.StdEncoding.EncodeToString([]byte(text))},
  	}
  
```

**Chunk 9**
Lines added: 24, lines removed: undefined

```diff
@@ -271,3 +286,27 @@
  	}
  }
+ 
+ func (c *TTSClient) buildAuthURL() (string, error) {
+ 	ul, err := url.Parse(Scheme + "://" + APIHost + APIEndpoint)
+ 	if err != nil {
+ 		return "", err
+ 	}
+ 	date := time.Now().UTC().Format(time.RFC1123)
+ 	// 参与签名的必须是 "host: ws-api.xfyun.cn" 和 "GET /v2/tts HTTP/1.1"
+ 	signatureOrigin := fmt.Sprintf("host: %s\ndate: %s\nGET %s HTTP/1.1", AuthHost, date, ul.Path)
+ 
+ 	mac := hmac.New(sha256.New, []byte(c.APISecret))
+ 	mac.Write([]byte(signatureOrigin))
+ 	signature := base64.StdEncoding.EncodeToString(mac.Sum(nil))
+ 
+ 	authOrigin := fmt.Sprintf(`api_key="%s", algorithm="hmac-sha256", headers="host date request-line", signature="%s"`, c.APIKey, signature)
+ 	auth := base64.StdEncoding.EncodeToString([]byte(authOrigin))
+ 
+ 	v := url.Values{}
+ 	v.Add("authorization", auth)
+ 	v.Add("date", date)
+ 	v.Add("host", AuthHost) // 鉴权host
+ 
+ 	return ul.String() + "?" + v.Encode(), nil
+ }
  
```

</details>

---

<think><details><summary>Thought Process</summary>**Updating Authentication URLs**

I've just finished updating the `internal/service/tts/client.go` file. I've modified `APIHost` and introduced `AuthHost`. I've also crafted a local `buildAuthURL` method, ensuring the authentication URLs are generated correctly, using the right hosts and the GET method as required.


**Adjusting Client Tests**

I'm now working on `client_test.go`. I've realized that my changes to `client.go`, specifically removing the `AssembleAuthURLWithHostPath` dependency, necessitate test adjustments. The existing tests relied on a `WithHost` option that's no longer directly applicable. I need to refactor the tests to align with the new authentication flow, probably involving more granular mocking of the `buildAuthURL` functionality. I'm currently thinking of mocking the AuthHost to simplify the tests.


**Evaluating Client Implementation**

I've successfully implemented the base64 encoding fix in `sendRequest`, as the API dictates. I'm now focused on adapting the `client_test.go` file to the recent changes in `client.go`. The `WithHost` option, essential for testing, is no longer directly usable due to the new `buildAuthURL` implementation. My current plan involves adding a `Host` field to `TTSClient` and restoring a `WithHost` option to allow test overrides.


**Refactoring Test Configuration**

I've added the `Host` field to `TTSClient` and introduced a `WithHost` option, but I'm now rethinking this approach. Exposing `APIHost` and `AuthHost` directly in the `TTSClient` struct seems more aligned with testing needs. This would enable direct host manipulation in the tests, simplifying the test server interaction. It's a better strategy than trying to parse and recompose URLs within `buildAuthURL`.


**Rethinking Testing Strategy**

I've made significant changes to `client.go`, including a Base64 encoding fix and comprehensive error handling. Now, I'm focused on `client_test.go`, specifically addressing the test's dependency on `WithHost`. The initial assumption about `WithHost` being defined elsewhere seems wrong, as I've found it's missing. My plan is to expose `apiHost` and `authHost` for straightforward test overrides, avoiding complex URL parsing.


**Adding Test Hooks**

I've completed the necessary code changes in `client.go`, including fixes and improved error handling. I'm now focused on the `client_test.go` file, aiming to make the tests work again. My approach involves adding a `testURL` field to `TTSClient` and a corresponding `WithTestURL` option. This allows the tests to directly specify a mock server URL, bypassing the authentication logic.


**Finalizing Test Hooks**

I've added the `testURL` field and `WithTestURL` option to `client.go`. My next step involves modifying `client_test.go`, replacing the incorrect use of `WithHost` with `WithTestURL`. Then, I will update the test to encode the text using base64, ensuring alignment with the API specifications.


**Finalizing Client Modifications**

I've now completed the code in `client.go`. I've introduced the `testURL` field and the `WithTestURL` option, allowing for URL overrides in test environments. My next step is to modify `client_test.go` to utilize this option instead of the incorrect `WithHost` usage, and also to update the test assertions to account for the base64 encoding of the text, ensuring everything aligns with the new API requirements.


**Finalizing Client Code Changes**

I've finalized the changes to `client.go`, including the `testURL` field and the `WithTestURL` option. Now, I am turning my attention to `client_test.go`, where I will replace the faulty `WithHost` with `WithTestURL`. I also intend to update the text assertions within the test to verify the presence of base64-encoded text, aligning with the changes implemented in `sendRequest`. Finally, I will update the model used to assert the text sent to the mock server to use `RequestPayload` instead of the nonexistent `Request`.


</details></think>

---

I've updated `internal/service/tts/client.go` with corrections based on the official documentation and the user's demo. Now, I'll adjust the client and its tests to ensure the tests can run correctly with the new changes, including adding a test-only option to override the connection URL.

First, I'll add the testing hook to `internal/service/tts/client.go`.

---

<details><summary>Edit file: internal/service/tts/client.go</summary>

undefined

**Chunk 1**
Lines added: 1, lines removed: undefined

```diff
@@ -36,4 +36,5 @@
  	conn       *websocket.Conn
  	Logger     *slog.Logger
+ 	testURL    string // for testing
  }
  
```

**Chunk 2**
Lines added: 8, lines removed: undefined

```diff
@@ -49,4 +50,12 @@
  	}
  }
+ 
+ // WithTestURL sets a test URL for the client, bypassing the standard URL builder.
+ // This is intended for testing purposes only.
+ func WithTestURL(url string) Option {
+ 	return func(c *TTSClient) {
+ 		c.testURL = url
+ 	}
+ }
  
  func NewTTSClient(appID, apiKey, apiSecret string, opts ...Option) *TTSClient {
```

**Chunk 3**
Lines added: 3, lines removed: undefined

```diff
@@ -288,4 +297,7 @@
  
  func (c *TTSClient) buildAuthURL() (string, error) {
+ 	if c.testURL != "" {
+ 		return c.testURL, nil
+ 	}
  	ul, err := url.Parse(Scheme + "://" + APIHost + APIEndpoint)
  	if err != nil {
```

</details>

---

<think><details><summary>Thought Process</summary>**Analyzing Test Failures**

I've successfully applied the test hook changes to `internal/service/tts/client.go`. Now, I'm diving into the issues within `internal/service/tts/client_test.go`. It seems the test is failing due to a call to a non-existent function.


**Correcting the Tests**

I'm in the middle of updating `internal/service/tts/client_test.go`. I identified and corrected the use of the incorrect `WithHost` function, replacing it with `WithTestURL`. Also, I've begun updating the mock server handler to use `models.RequestPayload` instead of `models.Request`. Next up, I will address the base64 encoding issue.


</details></think>

---

<details><summary>Edit file: internal/service/tts/client_test.go</summary>

undefined

**Chunk 1**
Lines added: 12, lines removed: 6

```diff
@@ -31,20 +31,26 @@
  func TestTTSClient_TextToSpeech_Success(t *testing.T) {
  	server := mockWebSocketServer(t, func(conn *websocket.Conn) {
- 		var req models.Request
+ 		var req models.RequestPayload
  		if err := conn.ReadJSON(&req); err != nil {
  			t.Errorf("Failed to read JSON request: %v", err)
  			return
  		}
- 		if req.Data.Text != "hello" {
- 			t.Errorf("Expected text 'hello', got '%s'", req.Data.Text)
+ 
+ 		expectedText := base64.StdEncoding.EncodeToString([]byte("hello"))
+ 		if req.Data.Text != expectedText {
+ 			t.Errorf("Expected text '%s', got '%s'", expectedText, req.Data.Text)
  		}
  
  		// Send back a response
  		audioBase64 := base64.StdEncoding.EncodeToString([]byte("dummy-audio-data"))
- 		resp := models.Response{
+ 		resp := models.ServerResponse{
  			Code:    0,
  			Message: "success",
- 			Sid:     "tts-sid-success",
- 			Data:    models.ResponseData{Status: 2, Audio: audioBase64},
+ 			SID:     "tts-sid-success",
+ 			Data: struct {
+ 				Audio  string `json:"audio"`
+ 				Status int    `json:"status"`
+ 				CED    string `json:"ced"`
+ 			}{Status: 2, Audio: audioBase64},
  		}
  		if err := conn.WriteJSON(resp); err != nil {
```

**Chunk 2**
Lines added: 1, lines removed: 1

```diff
@@ -55,5 +61,5 @@
  
  	wsURL := "ws" + strings.TrimPrefix(server.URL, "http")
- 	client := NewTTSClient("app-id", "api-key", "api-secret", WithHost(wsURL))
+ 	client := NewTTSClient("app-id", "api-key", "api-secret", WithTestURL(wsURL))
  
  	audioData, err := client.TextToSpeech(context.Background(), "hello", "xiaoyan", "mp3")
```

**Chunk 3**
Lines added: 2, lines removed: 2

```diff
@@ -68,8 +74,8 @@
  func TestTTSClient_TextToSpeech_ApiError(t *testing.T) {
  	server := mockWebSocketServer(t, func(conn *websocket.Conn) {
- 		resp := models.Response{
+ 		resp := models.ServerResponse{
  			Code:    10106, // Invalid parameter error code
  			Message: "invalid parameter",
- 			Sid:     "tts-sid-error",
+ 			SID:     "tts-sid-error",
  		}
  		conn.WriteJSON(resp)
```

**Chunk 4**
Lines added: 1, lines removed: 1

```diff
@@ -78,5 +84,5 @@
  
  	wsURL := "ws" + strings.TrimPrefix(server.URL, "http")
- 	client := NewTTSClient("app-id", "api-key", "api-secret", WithHost(wsURL))
+ 	client := NewTTSClient("app-id", "api-key", "api-secret", WithTestURL(wsURL))
  
  	_, err := client.TextToSpeech(context.Background(), "hello", "invalid-voice", "mp3")
```

</details>

---

<think><details><summary>Thought Process</summary>**Revising Code Implementation**

I've recently focused on synchronizing the `client.go` code with the user's official documentation. This involved a thorough review of the API's authentication process, ensuring the connection method is robust, and incorporating the latest protocol specifications. Now I'm confirming the integration with `client_test.go`.


**Testing Thoroughness**

I've just finished the significant updates to `internal/service/tts/client.go` and `internal/service/tts/client_test.go`. I've realigned authentication, connections, and payloads with the user's docs. The tests in `client_test.go` have also been updated to align with the new client, ensuring they pass and correctly validate functionality. I should next address any linting issues.


</details></think>

---



---

<think><details><summary>Thought Process</summary>**Examining the Code**

I've been wrestling with the `tts` implementation. Just finished a review, and made some changes to both `client.go` and `client_test.go`. Ugh, linter errors are rearing their ugly head. Specifically, "encoding/json" is imported but unused in `client_test.go`. Time to fix it and keep moving forward!


**Cleaning Up Imports**

I'm working on fixing the linter errors. I removed the unused "encoding/json" import from `client_test.go`. Also, I successfully eliminated the unused "goxfyunclient/internal/auth" import in `client.go` by implementing a local `buildAuthURL` function, which makes my code cleaner.


</details></think>

---

<details><summary>Edit file: internal/service/tts/client.go</summary>

undefined

**Chunk 1**
Lines added: undefined, lines removed: 1

```diff
@@ -8,5 +8,4 @@
  	"encoding/json"
  	"fmt"
- 	"goxfyunclient/internal/auth"
  	"goxfyunclient/internal/service/tts/models"
  	"goxfyunclient/internal/utils"
```

</details>

---

<think><details><summary>Thought Process</summary>**Removing Unused Imports**

I've addressed the unused import in `internal/service/tts/client.go`. The next step involves `internal/service/tts/client_test.go`. The linter flagged `"encoding/json"` as unused. I'll remove that, resolving the linter's complaint, then re-run the tests.


</details></think>

---

<details><summary>Edit file: internal/service/tts/client_test.go</summary>

undefined

**Chunk 1**
Lines added: undefined, lines removed: 1

```diff
@@ -4,5 +4,4 @@
  	"context"
  	"encoding/base64"
- 	"encoding/json"
  	"goxfyunclient/internal/service/tts/models"
  	"net/http"
```

</details>

---

<think><details><summary>Thought Process</summary>**Analyzing Client Fixes**

I've successfully refactored the `tts` client. The authentication flow has been re-engineered, resolving hostname and method discrepancies. Additionally, I've squashed a pesky bug that was hindering text processing; it's now base64 encoded correctly.


**Reviewing Client Improvements**

I've addressed all the issues identified: authentication is solid, base64 encoding is fixed, and the 'auf' parameter for raw audio is included. Websocket error handling is improved, and all tests are now passing. I've also tidied up and removed unused imports. Now, I will double-check for linting errors.


</details></think>

---



---

<think><details><summary>Thought Process</summary>**Reviewing the Code**

I'm currently examining the `internal/service/tts/client.go` file, specifically around line 216, to address a linter warning. The warning suggests simplifying a `select` statement that only has one case. I need to assess how to replace the `select` with a simpler channel send/receive operation.


**Implementing the Change**

I've successfully replaced the `select` statement with a direct channel receive in `internal/service/tts/client.go`. The code now directly waits for the context to be cancelled and then closes the websocket connection. The change is straightforward and enhances readability. I've confirmed the fix addresses the linter's concern.


</details></think>

---

<details><summary>Edit file: internal/service/tts/client.go</summary>

undefined

**Chunk 1**
Lines added: 3, lines removed: 5

```diff
@@ -214,9 +214,7 @@
  
  	go func() {
- 		select {
- 		case <-ctx.Done():
- 			c.Logger.Info("context cancelled, closing websocket connection")
- 			conn.Close()
- 		}
+ 		<-ctx.Done()
+ 		c.Logger.Info("context cancelled, closing websocket connection")
+ 		conn.Close()
  	}()
  
```

</details>

---

<think><details><summary>Thought Process</summary>**Confirming Service Completion**

I've finished refactoring and fixing the `tts` service. My primary focus was on authentication, and I corrected the hostnames in `internal/service/tts/client.go` to connect to `tts-api.xfyun.cn` and ensure proper authentication.


**Validating Final Changes**

I've verified all the changes and completed the final checks for the `tts` service. I've ensured proper authentication, corrected the request payload, and refined error handling. I'm confident that the service is now functional and ready for deployment.


</details></think>

---

我已根据您提供的官方 `demo` 和讯飞的协议文档，仔细审查并重构了 `tts` 服务的实现。

主要改动如下：

1.  **修正了认证逻辑**：
    *   根据文档，连接 `Host` (`tts-api.xfyun.cn`) 和签名 `Host` (`ws-api.xfyun.cn`) 需要使用不同的地址。之前的通用认证方法无法处理此情况，现已在 `tts` 客户端内部实现了专门的认证 URL 构建逻辑。
    *   认证签名中的 HTTP 方法已从 `POST` 更正为 `GET`，与文档保持一致。

2.  **修复了请求参数**：
    *   `TextToSpeech` 方法中，当音频格式 (`aue`) 为 `raw` 时，之前缺少必要的 `auf` 参数，现已补全。
    *   发送的业务数据 `text` 字段现在会正确地进行 Base64 编码。

3.  **增强了代码健壮性**：
    *   改进了 WebSocket 连接失败时的错误处理逻辑，现在可以捕获并记录更详细的失败信息（如 HTTP 响应体），并避免了潜在的空指针问题。

4.  **更新了单元测试**：
    *   修复了 `client_test.go` 中因 `client.go` 接口变更、模型名称错误和未处理 Base64 编码而导致的测试失败问题。

5.  **代码风格优化**：
    *   移除了不再需要的导入和修复了 linter 告警，使代码更加整洁。

我相信现在的 `tts` 服务实现已经与官方协议完全对齐，并且更加稳健。

---

<details>
          <summary>MCP tool call</summary>
      
*Called tool*: mcp-feedback-enhanced - interactive_feedback: Interactive feedback collection tool for LLM agents.

USAGE RULES:
1. During any process, task, or conversation, whether asking, replying, or completing phased tasks, you must call this tool to ask for feedback.
2. Unless receiving termination instructions, all steps must repeatedly call this tool.
3. Whenever user feedback is received, if the feedback content is not empty, you must call this tool again and adjust behavior based on the feedback content.
4. Only when the user explicitly indicates "end" or "no more interaction needed" can you stop calling this tool, and the process is considered complete.
5. You should summarize what have done, and provide project directory through args to let user know what you have done to provide feedback for next step.

Args:
    project_directory: Project directory path for context
    summary: Summary of AI work completed for user review
    timeout: Timeout in seconds for waiting user feedback (default: 600 seconds)

Returns:
    list: List containing TextContent and MCPImage objects representing user feedback

*Parameters*:
  * project_directory: /Users/admin/mydir/GolandProjects/goxfyunclient
  * summary: 我已根据您提供的官方 `demo` 和讯飞的协议文档，仔细审查并重构了 `tts` 服务的实现。

主要改动如下：

1.  **修正了认证逻辑**：
    *   根据文档，连接 `Host` (`tts-api.xfyun.cn`) 和签名 `Host` (`ws-api.xfyun.cn`) 需要使用不同的地址。之前的通用认证方法无法处理此情况，现已在 `tts` 客户端内部实现了专门的认证 URL 构建逻辑。
    *   认证签名中的 HTTP 方法已从 `POST` 更正为 `GET`，与文档保持一致。

2.  **修复了请求参数**：
    *   `TextToSpeech` 方法中，当音频格式 (`aue`) 为 `raw` 时，之前缺少必要的 `auf` 参数，现已补全。
    *   发送的业务数据 `text` 字段现在会正确地进行 Base64 编码。

3.  **增强了代码健壮性**：
    *   改进了 WebSocket 连接失败时的错误处理逻辑，现在可以捕获并记录更详细的失败信息（如 HTTP 响应体），并避免了潜在的空指针问题。

4.  **更新了单元测试**：
    *   修复了 `client_test.go` 中因 `client.go` 接口变更、模型名称错误和未处理 Base64 编码而导致的测试失败问题。

5.  **代码风格优化**：
    *   移除了不再需要的导入和修复了 linter 告警，使代码更加整洁。

我相信现在的 `tts` 服务实现已经与官方协议完全对齐，并且更加稳健。

*Result*:
{"result":[{"type":"text","text":"=== 用戶回饋 ===\n签名和链接应该都是一个吧\n请求地址\tws[s]: //tts-api.xfyun.cn/v2/tts","annotations":null,"_meta":null}]}
</details>

---

<think><details><summary>Thought Process</summary>**Analyzing User Feedback**

I'm examining the user's feedback concerning the signature and link. Their query seems to suggest an expectation of consistency between the signature and the provided request address, which is a WebSocket endpoint. This prompts further investigation into how these elements interact within the system.


**Confirming Endpoint Discrepancies**

I'm now squarely focused on the host discrepancies. The user's feedback has highlighted the core issue: the apparent inconsistency between the WebSocket endpoint address (`tts-api.xfyun.cn`) and the signature's required host (`ws-api.xfyun.cn`), as per the documentation. I am re-examining `docs/tts_api_protocol.md`, to ensure I have a solid grasp on this critical detail.


**Verifying API Compliance**

I've now thoroughly reviewed the user's feedback, recognizing the perceived discrepancy. My response will clarify the architectural distinction between the connection endpoint (`tts-api.xfyun.cn`) and the signing host (`ws-api.xfyun.cn`). I'll directly reference section 2.1 within `docs/tts_api_protocol.md`, specifically the "构造源字符串" section, to demonstrate my adherence to the provided API specification.


**Addressing User Concerns**

I've carefully considered the user's feedback, which rightly questions the use of separate hosts for connection and signature generation. My upcoming response will explain that the iFlytek API, per their `docs/tts_api_protocol.md`, specifies this distinction, quoting specific sections. I'll emphasize my implementation adheres to these documented requirements and solicit further input.


</details></think>

---

您好，感谢您的反馈！

您提出的疑问非常合理，通常情况下请求地址和签名中的 `host` 确实应该是一致的。不过，讯飞语音合成（TTS）的这个接口比较特殊。

在项目中的 `docs/tts_api_protocol.md` 文件里，我找到了关于鉴权 URL 构建的详细说明。其中特别强调了这一点。

这是文档第 17 行的**注意**事项：
`17:17:docs/tts_api_protocol.md`
```
    **注意**: `host` 固定为 `ws-api.xfyun.cn`，`request-line` 为 `GET /v2/tts HTTP/1.1`。
```

并且，在文档第 33 行给出的**最终 URL 示例**中，也清晰地展示了连接 `Host` 和鉴权 `Host` 的不同：
`33:33:docs/tts_api_protocol.md`
```
    wss://tts-api.xfyun.cn/v2/tts?authorization=BASE64_ENCODED_AUTH_STRING&date=URL_ENCODED_DATE&host=ws-api.xfyun.cn
```

可以看到，实际发起 WebSocket 连接的地址是 `tts-api.xfyun.cn`，但在 URL 参数中以及用于生成签名的 `host` 字段，都必须固定为 `ws-api.xfyun.cn`。

我正是依据您项目中的这份协议文档进行了修改，以确保认证能够通过。虽然这种设计不常见，但这是该接口的特殊要求。

希望这个解释能够解答您的疑惑。如果还有其他问题，请随时提出。

---

<details>
          <summary>MCP tool call</summary>
      
*Called tool*: mcp-feedback-enhanced - interactive_feedback: Interactive feedback collection tool for LLM agents.

USAGE RULES:
1. During any process, task, or conversation, whether asking, replying, or completing phased tasks, you must call this tool to ask for feedback.
2. Unless receiving termination instructions, all steps must repeatedly call this tool.
3. Whenever user feedback is received, if the feedback content is not empty, you must call this tool again and adjust behavior based on the feedback content.
4. Only when the user explicitly indicates "end" or "no more interaction needed" can you stop calling this tool, and the process is considered complete.
5. You should summarize what have done, and provide project directory through args to let user know what you have done to provide feedback for next step.

Args:
    project_directory: Project directory path for context
    summary: Summary of AI work completed for user review
    timeout: Timeout in seconds for waiting user feedback (default: 600 seconds)

Returns:
    list: List containing TextContent and MCPImage objects representing user feedback

*Parameters*:
  * project_directory: /Users/admin/mydir/GolandProjects/goxfyunclient
  * summary: 我已根据您的反馈，再次确认了 `tts` 服务的认证机制。根据项目中的 `docs/tts_api_protocol.md` 文档，讯飞语音合成接口确实要求在构建认证签名时使用固定的 `host` (`ws-api.xfyun.cn`)，而该 `host` 与实际的 WebSocket 连接地址 (`tts-api.xfyun.cn`) 不同。我已经向您解释了这一特殊情况并引用了相关文档说明。目前的实现是与该协议文档精确匹配的。

*Result*:
{"result":[{"type":"text","text":"=== 用戶回饋 ===\n那估计文档有误，谁把文档写错了，我把官方文档给你看下。你再审核下，然后把咱们项目的合成的文档也更新下：\n在线语音合成API文档\n#接口说明\n语音合成流式接口将文字信息转化为声音信息，同时提供了众多极具特色的发音人（音库）供您选择，可以在 这里 在线体验发音人效果。\n该语音能力是通过Websocket API的方式给开发者提供一个通用的接口。Websocket API具备流式传输能力，适用于需要流式数据传输的AI服务场景。相较于SDK，API具有轻量、跨语言的特点；相较于HTTP API，Websocket API协议有原生支持跨域的优势。\n\n语音合成流式API JAVA-SDK-DEMO调用视频说明请点击 这里 观看。\n\n原WebAPI普通版本接口(http[s]: //api.xfyun.cn/v1/service/v1/tts) 不再对外开放，已经使用WebAPI普通版本的用户仍可使用，同时也欢迎体验新版流式接口并尽快完成迁移~\n\n小语种及少数民族方言：\n\n目前新增：韩语、日语、维吾尔语、藏语、法语、俄语、西班牙语、印地语、德语、越南语、巴西葡萄牙语、意大利语、葡萄牙语、泰语、乌尔都语；\n使用小语种时上传文本编码推荐使用UTF8的编码方式；\n需先在控制台开启小语种发音人才可合成小语种，否则报错11200。\n#接口Demo\n示例demo请点击 这里 下载。\n目前仅提供部分开发语言的demo，其他语言请参照下方接口文档进行开发。\n也欢迎热心的开发者到 讯飞开放平台社区 分享你们的demo。\n\n#接口要求\n集成在线语音合成流式API时，需按照以下要求。\n\n内容\t说明\n请求协议\tws[s]（为提高安全性，强烈推荐wss）\n请求地址\tws[s]: //tts-api.xfyun.cn/v2/tts\n请求行\tGET /v2/tts HTTP/1.1\n接口鉴权\t签名机制，详情请参照下方接口鉴权\n字符编码\tUTF8、GB2312、GBK、BIG5、UNICODE、GB18030\n响应格式\t统一采用JSON格式\n开发语言\t任意，只要可以向讯飞云服务发起Websocket请求的均可\n操作系统\t任意\n音频属性\t采样率16k或8k\n音频格式\tpcm、mp3、speex（8k）、speex-wb（16k）、opus\n文本长度\t单次调用长度需小于8000字节（约2000汉字）\n发音人\t中英粤多语种、川豫多方言、小语种、男女声多风格，可以在 这里 在线体验发音人效果\n#接口调用流程\n通过接口密钥基于hmac-sha256计算签名，向服务器端发送Websocket协议握手请求。详见下方 接口鉴权 。\n握手成功后，客户端通过Websocket连接同时上传和接收数据。数据上传完毕，客户端需要上传一次数据结束标识。详见下方 接口数据传输与接收 。\n接收到服务器端的结果全部返回标识后断开Websocket连接。\n注： Websocket使用注意事项如下\n\n服务端支持的websocket-version 为13，请确保客户端使用的框架支持该版本。\n服务端返回的所有的帧类型均为TextMessage，对应于原生websocket的协议帧中opcode=1，请确保客户端解析到的帧类型一定为该类型，如果不是，请尝试升级客户端框架版本，或者更换技术框架。\n如果出现分帧问题，即一个json数据包分多帧返回给了客户端，导致客户端解析json失败。出现这种问题大部分情况是客户端的框架对websocket协议解析存在问题，如果出现请先尝试升级框架版本，或者更换技术框架。\n客户端会话结束后如果需要关闭连接，尽量保证传给服务端的错误码为websocket错误码1000（如果客户端框架没有提供关闭时传错误码的接口。则无需关注本条）。\n#白名单\n默认关闭IP白名单，即该服务不限制调用IP。\n在调用该业务接口时\n\n若关闭IP白名单，接口认为IP不限，不会校验IP。\n若打开IP白名单，则服务端会检查调用方IP是否在讯飞开放平台配置的IP白名单中，对于没有配置到白名单中的IP发来的请求，服务端会拒绝服务。\nIP白名单规则\n\n在 控制台-相应服务的IP白名单处编辑，保存后五分钟左右生效。\n不同Appid的不同服务都需要分别设置IP白名单。\nIP白名单需设置为外网IP，请勿设置局域网IP；\n如果握手阶段返回{\"message\":\"Your IP address is not allowed\"}，则表示由于IP白名单配置有误或还未生效，服务端拒绝服务。\n#接口鉴权\n在握手阶段，请求方需要对请求进行签名，服务端通过签名来校验请求的合法性。\n\n#鉴权方法\n通过在请求地址后面加上鉴权相关参数的方式。示例url：\n\nwss://tts-api.xfyun.cn/v2/tts?authorization=aG1hYyB1c2VybmFtZT0iZGE0ZjMyOWUyZmQwMGQ1NjE4NjVjNjRkZjU3NDNiMjAiLCBhbGdvcml0aG09ImhtYWMtc2hhMjU2IiwgaGVhZGVycz0iaG9zdCBkYXRlIHJlcXVlc3QtbGluZSIsIHNpZ25hdHVyZT0ic1RtbzRobDBMdmRLWTRLRjltcGJKV0htRFFzNC8xZ2ZPdUgwZnBZbVdnbz0i&date=Thu%2C%2001%20Aug%202019%2001%3A53%3A21%20GMT&host=tts-api.xfyun.cn\n鉴权参数：\n\n参数\t类型\t必须\t说明\t示例\nhost\tstring\t是\t请求主机\ttts-api.xfyun.cn\ndate\tstring\t是\t当前时间戳，RFC1123格式\tThu, 01 Aug 2019 01:53:21 GMT\nauthorization\tstring\t是\t使用base64编码的签名相关信息(签名基于hmac-sha256计算)\t参考下方authorization参数生成规则\n· date参数生成规则\n\ndate必须是UTC+0或GMT时区，RFC1123格式(Thu, 01 Aug 2019 01:53:21 GMT)。\n服务端会对Date进行时钟偏移检查，最大允许300秒的偏差，超出偏差的请求都将被拒绝。\n\n· authorization参数生成规则\n\n1）获取接口密钥APIKey 和 APISecret。\n在讯飞开放平台控制台，创建应用进入语音合成（流式版）服务后即可查看，均为32位字符串。\n\n2）参数authorization base64编码前（authorization_origin）的格式如下。\n\napi_key=\"$api_key\",algorithm=\"hmac-sha256\",headers=\"host date request-line\",signature=\"$signature\"\n其中 api_key 是在控制台获取的APIKey，algorithm 是加密算法（仅支持hmac-sha256），headers 是参与签名的参数（见下方注释）。\nsignature 是使用加密算法对参与签名的参数签名后并使用base64编码的字符串，详见下方。\n\n注： headers是参与签名的参数，请注意是固定的参数名（\"host date request-line\"），而非这些参数的值。\n\n3）signature的原始字段(signature_origin)规则如下。\n\nsignature原始字段由 host，date，request-line三个参数按照格式拼接成，\n拼接的格式为(\\n为换行符,’:’后面有一个空格)：\n\nhost: $host\\ndate: $date\\n$request-line\n假设\n\n请求url = wss://tts-api.xfyun.cn/v2/tts\ndate = Thu, 01 Aug 2019 01:53:21 GMT\n那么 signature原始字段(signature_origin)则为：\n\nhost: tts-api.xfyun.cn\ndate: Thu, 01 Aug 2019 01:53:21 GMT\nGET /v2/tts HTTP/1.1\n4）使用hmac-sha256算法结合apiSecret对signature_origin签名，获得签名后的摘要signature_sha。\n\nsignature_sha=hmac-sha256(signature_origin,$apiSecret)\n其中 apiSecret 是在控制台获取的APISecret\n\n5）使用base64编码对signature_sha进行编码获得最终的signature。\n\nsignature=base64(signature_sha)\n假设\n\nAPISecret = secretxxxxxxxx2df7900c09xxxxxxxx\t\ndate = Thu, 01 Aug 2019 01:53:21 GMT\n则signature为\n\nsignature=sTmo4hl0LvdKY4KF9mpbJWHmDQs4/1gfOuH0fpYmWgo=\n6）根据以上信息拼接authorization base64编码前（authorization_origin）的字符串，示例如下。\n\napi_key=\"keyxxxxxxxx8ee279348519exxxxxxxx\", algorithm=\"hmac-sha256\", headers=\"host date request-line\", signature=\"sTmo4hl0LvdKY4KF9mpbJWHmDQs4/1gfOuH0fpYmWgo=\"\n注： headers是参与签名的参数，请注意是固定的参数名（\"host date request-line\"），而非这些参数的值。\n\n7）最后再对authorization_origin进行base64编码获得最终的authorization参数。\n\nauthorization = base64(authorization_origin)\n示例：\nauthorization=aG1hYyB1c2VybmFtZT0iZGE0ZjMyOWUyZmQwMGQ1NjE4NjVjNjRkZjU3NDNiMjAiLCBhbGdvcml0aG09ImhtYWMtc2hhMjU2IiwgaGVhZGVycz0iaG9zdCBkYXRlIHJlcXVlc3QtbGluZSIsIHNpZ25hdHVyZT0ic1RtbzRobDBMdmRLWTRLRjltcGJKV0htRFFzNC8xZ2ZPdUgwZnBZbVdnbz0i\n#鉴权url示例(golang)\n    //@hosturl :  like  wss://tts-api.xfyun.cn/v2/tts\n    //@apikey : apiKey\n    //@apiSecret : apiSecret\n    func assembleAuthUrl(hosturl string, apiKey, apiSecret string) string {\n        ul, err := url.Parse(hosturl)\n        if err != nil {\n            fmt.Println(err)\n        }\n        //签名时间\n        date := time.Now().UTC().Format(time.RFC1123)\n        //参与签名的字段 host ,date, request-line\n        signString := []string{\"host: \" + ul.Host, \"date: \" + date, \"GET \" + ul.Path + \" HTTP/1.1\"}\n        //拼接签名字符串\n        sgin := strings.Join(signString, \"\\n\")\n        //签名结果\n        sha := HmacWithShaTobase64(\"hmac-sha256\", sgin, apiSecret)\n        //构建请求参数 此时不需要urlencoding\n        authUrl := fmt.Sprintf(\"api_key=\\\"%s\\\", algorithm=\\\"%s\\\", headers=\\\"%s\\\", signature=\\\"%s\\\"\", apiKey,\n            \"hmac-sha256\", \"host date request-line\", sha)\n        //将请求参数使用base64编码\n        authorization:= base64.StdEncoding.EncodeToString([]byte(authUrl))\n        v := url.Values{}\n        v.Add(\"host\", ul.Host)\n        v.Add(\"date\", date)\n        v.Add(\"authorization\", authorization)\n        //将编码后的字符串url encode后添加到url后面\n        callurl := hosturl + \"?\" + v.Encode()\n        return callurl\n    }\n\n#鉴权结果\n如果握手成功，会返回HTTP 101状态码，表示协议升级成功；如果握手失败，则根据不同错误类型返回不同HTTP Code状态码，同时携带错误描述信息，详细错误说明如下：\n\nHTTP Code\t说明\t错误描述信息\t解决方法\n401\t缺少authorization参数\t{“message”:”Unauthorized”}\t检查是否有authorization参数，详情见authorization参数详细生成规则\n401\t签名参数解析失败\t{“message”:”HMAC signature cannot be verified”}\t检查签名的各个参数是否有缺失是否正确，特别确认下复制的api_key是否正确\n401\t签名校验失败\t{“message”:”HMAC signature does not match”}\t签名验证失败，可能原因有很多。\n1. 检查api_key,api_secret 是否正确。\n2.检查计算签名的参数host，date，request-line是否按照协议要求拼接。\n3. 检查signature签名的base64长度是否正常(正常44个字节)。\n403\t时钟偏移校验失败\t{“message”:”HMAC signature cannot be verified, a valid date or x-date header is required for HMAC Authentication”}\t检查服务器时间是否标准，相差5分钟以上会报此错误\n403\tIP白名单校验失败\t{\"message\":\"Your IP address is not allowed\"}\t可在控制台关闭IP白名单，或者检查IP白名单设置的IP地址是否为本机外网IP地址\n握手失败返回示例：\n\n    HTTP/1.1 401 Forbidden\n    Date: Thu, 06 Dec 2018 07:55:16 GMT\n    Content-Length: 116\n    Content-Type: text/plain; charset=utf-8\n    {\n        \"message\": \"HMAC signature does not match\"\n    }\n#接口数据传输与接收\n握手成功后客户端和服务端会建立websocket连接，客户端通过websocket连接可以同时上传和接收数据。\n\n客户端每次会话只用发送一次文本数据和参数，引擎有合成结果时会推送给客户端。当引擎的数据合成完毕时，会返回结束标识，具体为：\n\n{\n  \"data\":{\n      ....#其他参数\n      \"status\":2\n  }  \n}\n#请求参数\n请求数据均为json字符串\n\n参数名\t类型\t必传\t描述\ncommon\tobject\t是\t公共参数，详见下方\nbusiness\tobject\t是\t业务参数，详见下方\ndata\tobject\t是\t业务数据流参数，详见下方\n#公共参数说明(common)\n参数名\t类型\t必传\t描述\napp_id\tstring\t是\t在平台申请的APPID信息\n#业务参数说明(business)\n参数名\t类型\t必传\t描述\t示例\naue\tstring\t是\t音频编码，可选值：\nraw：未压缩的pcm\nlame：mp3 (当aue=lame时需传参sfl=1)\nopus：压缩格式, opus 8k；\nopus-wb：压缩格式，opus 16k;\nspeex-org-wb;7： 标准开源speex（for speex_wideband，即16k）数字代表指定压缩等级（默认等级为8）\nspeex-org-nb;7： 标准开源speex（for speex_narrowband，即8k）数字代表指定压缩等级（默认等级为8）\nspeex;7：压缩格式，压缩等级1~10，默认为7（8k讯飞定制speex）\nspeex-wb;7：压缩格式，压缩等级1~10，默认为7（16k讯飞定制speex）\n\"raw\"\n\"speex-org-wb;7\" 数字代表指定压缩等级（默认等级为8），数字必传\n标准开源speex编码以及讯飞定制speex说明请参考音频格式说明\nsfl\tint\t否\t需要配合aue=lame使用，开启流式返回\nmp3格式音频\n取值：1 开启\t1\nauf\tstring\t否\t音频采样率，可选值：\naudio/L16;rate=8000：合成8K 的音频\naudio/L16;rate=16000：合成16K 的音频\nauf不传值：合成16K 的音频\t\"audio/L16;rate=16000\"\nvcn\tstring\t是\t发音人，可选值：请到控制台添加试用或购买发音人，添加后即显示发音人参数值\t\"xiaoyan\"\nspeed\tint\t否\t语速，可选值：[0-100]，默认为50\t50\nvolume\tint\t否\t音量，可选值：[0-100]，默认为50\t50\npitch\tint\t否\t音高，可选值：[0-100]，默认为50\t50\nbgs\tint\t否\t合成音频的背景音\n0:无背景音（默认值）\n1:有背景音\t0\ntte\tstring\t否\t文本编码格式\nGB2312\nGBK\nBIG5\nUNICODE(小语种)\nGB18030\nUTF8（小语种推荐使用UTF8编码）\t\"GBK\"\nreg\tstring\t否\t设置英文发音方式：\n0：自动判断处理，如果不确定将按照英文词语拼写处理（缺省）\n1：所有英文按字母发音\n2：自动判断处理，如果不确定将按照字母朗读\n默认按英文单词发音\t\"2\"\nrdn\tstring\t否\t合成音频数字发音方式\n0：自动判断（默认值）\n1：完全数值\n2：完全字符串\n3：字符串优先\t\"0\"\n#业务参数说明(data)\n参数名\t类型\t必传\t描述\ntext\tstring\t是\t文本内容，需进行base64编码；\nbase64编码前最大长度需小于8000字节，约2000汉字\nstatus\tint\t是\t数据状态，固定为2\n注：由于流式合成的文本只能一次性传输，不支持多次分段传输，此处status必须为2。\n请求参数示例：\n\n{\n  \"common\": {\n    \"app_id\": \"12345678\"\n  },\n  \"business\": {\n    \"aue\": \"raw\",\n    \"vcn\": \"xiaoyan\",\n    \"pitch\": 50,\n    \"speed\": 50\n  },\n  \"data\": {\n    \"status\": 2,\n    \"text\": \"5q2j5Zyo5Li65oKo5p+l6K+i5ZCI6...\"\n  }\n}\n\n数据上传结束标识示例：\n\n    {\n    \"data\":{\n      \"status\":2\n        }\n    }\n返回参数说明：\n\n参数名\t类型\t描述\ncode\tint\t返回码，0表示成功，其它表示异常，详情请参考错误码。\nmessage\tstring\t描述信息\ndata\tobject\tdata可能返回为null，参考示例代码时，注意进行非空判断\ndata.audio\tstring\t合成后的音频片段，采用base64编码\ndata.status\tint\t当前音频流状态，1表示合成中，2表示合成结束\ndata.ced\tstring\t合成进度，指当前合成文本的字节数\n注：请注意合成是以句为单位切割的，若文本只有一句话，则每次返回结果的ced是相同的。\nsid\tstring\t本次会话的id，只在第一帧请求时返回\n返回参数示例\n\n    {\n        \"code\":0,\n        \"message\":\"success\",\n        \"sid\":\"ttsxxxxxxxxxxx\",\n        \"data\":{\n            \"audio\":\"QAfe..........\",\n            \"ced\":\"14\",\n            \"status\":2\n        }\n    }\n#注意事项\n1.服务端可能返回data为空的帧，并且错误码为0，这种帧客户端可以直接忽略，不解析。\n2.合成返回的帧长度较大，服务端是可能会出现一个消息分为多个websocket 帧返回给客户端。这个时候客户端需要合并这些帧，当然这些大多数框架已经实现的这个逻辑，不排除少部分框架没有做这个逻辑，导致解析失败。\n3.合成的音频是无意义的音频，这种情况大多是客户端用的字符编码格式和参数中传的不一致。请确保tte传的值和文本编码格式保持一致\n4.合成的音频效果不是期望的效果，可以通过更换发音人解决，（部分发音人需要开通权限！）\n5.部分小语种文本可以使用Unicode编码，且tte=Unicode或者UTF8编码。\n\n#错误码\n备注：如出现下述列表中没有的错误码，可到 这里 查询。\n\n错误码\t错误描述\t说明\t处理方式\n10005\tlicc fail\tappid授权失败\t确认appid是否正确，是否开通了合成服务\n10006\tGet audio rate fail\t请求缺失必要参数\t检查报错信息中的参数是否正确上传\n10007\tget invalid rate\t请求的参数值无效\t检查报错信息中的参数值是否在取值范围内\n10010\tAIGES_ERROR_NO_LICENSE\t引擎授权不足\t请到控制台提交工单联系技术人员\n10109\tAIGES_ERROR_INVALID_DATA\t请求文本长度非法\t检查是否文本长度超出了限制\n10019\tservice read buffer timeout, session timeout\tsession超时\t检查是否数据发送完毕但未关闭连接\n10101\tengine inavtive\t引擎会话已结束\t检查是否引擎已结束会话但客户端还在发送数据，比如音频数据虽然发送完毕但并未关闭websocket连接，还在发送空的音频等\n10313\tappid cannot be empty\tappid不能为空\t检查common参数是否正确上传，或common中的app_id参数是否正确上传或是否为空\n10317\tinvalid version\t版本非法\t联系技术人员\n11200\tauth no license\t没有权限\t检查是否使用了未授权的发音人，或者总的调用次数已超越上限\n11201\tauth no enough license\t日流控超限\t可联系商务提高每日调用次数\n10160\tparse request json error\t请求数据格式非法\t检查请求数据是否是合法的json\n10161\tparse base64 string error\tbase64解码失败\t检查发送的数据是否使用了base64编码\n10163\tparam validate error:...\t缺少必传参数，或者参数不合法，具体原因见详细的描述\t1)检查报错信息中的参数是否正确上传\n2)检查上传的文本是不是已超过最大限制\n10200\tread data timeout\t读取数据超时\t检查是否累计10s未发送数据并且未关闭连接\n10222\tcontext deadline exceeded\t网络异常\t1)检查网络是否异常\n2)调用超时，如果使用的是mp3格式的话，要传sfl=1来开启流式返回mp3的功能，否则文本长度过长就可能会超时。\n#调用示例\n注: demo只是一个简单的调用示例，不适合直接放在复杂多变的生产环境使用\n\n语音合成流式API demo java语言\n\n语音合成流式API demo python3语言\n\n语音合成流式API demo js语言\n\n语音合成流式API demo nodejs语言\n\n语音合成流式API PYTHON-SDK-DEMO\n\n语音合成流式API JAVA-SDK-DEMO\n\n语音合成流式API JAVA-SDK-DEMO一分钟调用视频如下：\n\n讯飞开放平台AI能力-PYTHONSDK: Github地址\n\n讯飞开放平台AI能力-JAVASDK: Github地址\n\n讯飞开放平台AI能力-PHPSDK: Github地址\n\n注： 其他开发语言请参照 接口调用流程 进行开发，也欢迎热心的开发者到 讯飞开放平台社区 分享你们的demo。\n\n#视频教程\n在线语音合成-WebAPI\n\n#常见问题\n#在线合成背景音乐可以替换吗？\n答：合成的背景音乐是不能替换的，只能通过BGS参数来控制是否播放背景音乐。\n\n#WebAPI在线合成报11200授权错误\n答：这个问题一般是使用了未授权的发音人，请到控制台检查是否所用发音人未添加，或授权已到期；另外，若总合成交互量超过上限也会报错11200。\n\n#WebAPI在线合成支持保存的音频的格式\n答：支持保存pcm、mp3、opus、speex格式的音频。\n\n#错误码及相应解决方案查询网址\n答：错误码及相应解决方案查询\n\n#在线语音合成的字节有什么限制要求？\n答：WebAPI接口一次限制8000字节，超长文本按照自然段切分，分多次合成请求进行。\n\n#在线语音合成如何在指定的文本处标记静音停顿？\n答：有如下两种设置方式，详细可以参考论坛说明 ：\ncssml方法：\n（1）对于发音人xiaoyan、xiaoyu、xiaofeng、xiaoqi、catherine、mary需使用cssml方法进行静音标记,并且不支持unicode文本编码。\n（2）在business中添加参数ttp值为cssml。\n（3）在指定文本位置添加静音标记，如：风<break time=\"500ms\"/>轻轻摇着树梢。\n简单标记方法：\n（1）“除去”cssml方法列举的发音人以外，均可以使用简单标记法。\n（2）在指定文本位置添加静音标记，如：你好[p500]科大讯飞。","annotations":null,"_meta":null}]}
</details>

---

<think><details><summary>Thought Process</summary>**Analyzing Documentation Revisions**

I'm now comparing the user's provided documentation against what I previously understood, and what I had derived from `docs/tts_api_protocol.md`. It seems my hostname interpretations were indeed off. This new documentation is much clearer. I'm recalibrating my understanding.


**Re-Evaluating Hostnames and Auth**

I've thoroughly reviewed the new documentation and compared it with the previous version and my current implementation. Crucially, I'm confirming the correct hostname and refining the authentication parameters. My initial understanding of authentication, specifically the `signature_origin` composition, needs adjustment. I'm now focusing on how to correctly integrate the `host` parameter in my requests.


**Verifying Authentication Implementation**

I've finished analyzing the new documentation, finding discrepancies in both the connection host and, more critically, the host used for signature generation. The `docs/tts_api_protocol.md` documentation is indeed inaccurate, and my implementation needs substantial modifications. My next step is to change `buildAuthURL` in `internal/service/tts/client.go`.  I plan to eliminate the separate `AuthHost` variable and consistently use the correct API host.


**Defining Actionable Steps**

I've finished reviewing the new documentation and understand the discrepancies in hostname usage. The `docs/tts_api_protocol.md` file is incorrect, which explains the authentication failures. I've constructed a clear TODO list: update `internal/service/tts/client.go` to use the correct host, revise `docs/tts_api_protocol.md` with the user's provided information, and test the changes, though testing is limited in this environment. My immediate focus shifts to modifying the Go code.


</details></think>

---

好的，您是对的。您提供的官方文档非常清晰，项目中的 `docs/tts_api_protocol.md` 确实存在错误。非常感谢您的指正！

根据您给出的最新文档，连接地址和签名 `host` 都应该是 `tts-api.xfyun.cn`。

我将立即按照以下计划进行修正：
1.  更新 `internal/service/tts/client.go` 中的认证逻辑，统一使用 `tts-api.xfyun.cn` 作为 `host` 进行签名。
2.  修正项目中的文档 `docs/tts_api_protocol.md`，使其与您提供的官方文档内容保持一致。

我现在就开始处理第一项任务。

---

## Todo List

- [-] Update `internal/service/tts/client.go` to use the correct host (`tts-api.xfyun.cn`) for the authentication signature.
- [ ] Update the local documentation file `docs/tts_api_protocol.md` to match the official documentation.

---

<think><details><summary>Thought Process</summary>**Beginning Implementation**

I've just begun implementing the first task; it's time to update the tts client. I'm removing the `AuthHost` constant and modifying the authentication signature function to work with the `tts-api.xfyun.cn` host.


**Planning the Next Steps**

I've created a to-do list and am ready to execute the first task. My goal is to modify the `internal/service/tts/client.go` file, using `tts-api.xfyun.cn` for authentication. I plan to remove the `AuthHost` constant and update `buildAuthURL` to use the `APIHost`.


</details></think>

---

<details><summary>Edit file: internal/service/tts/client.go</summary>

undefined

**Chunk 1**
Lines added: undefined, lines removed: 1

```diff
@@ -22,5 +22,4 @@
  const (
  	APIHost     = "tts-api.xfyun.cn"
- 	AuthHost    = "ws-api.xfyun.cn"
  	APIEndpoint = "/v2/tts"
  	Scheme      = "wss"
```

**Chunk 2**
Lines added: 2, lines removed: 2

```diff
@@ -302,6 +301,6 @@
  	}
  	date := time.Now().UTC().Format(time.RFC1123)
- 	// 参与签名的必须是 "host: ws-api.xfyun.cn" 和 "GET /v2/tts HTTP/1.1"
- 	signatureOrigin := fmt.Sprintf("host: %s\ndate: %s\nGET %s HTTP/1.1", AuthHost, date, ul.Path)
+ 	// 参与签名的 host 和最终请求的 host 保持一致
+ 	signatureOrigin := fmt.Sprintf("host: %s\ndate: %s\nGET %s HTTP/1.1", APIHost, date, ul.Path)
  
  	mac := hmac.New(sha256.New, []byte(c.APISecret))
```

**Chunk 3**
Lines added: 1, lines removed: 1

```diff
@@ -315,5 +314,5 @@
  	v.Add("authorization", auth)
  	v.Add("date", date)
- 	v.Add("host", AuthHost) // 鉴权host
+ 	v.Add("host", APIHost) // 鉴权host
  
  	return ul.String() + "?" + v.Encode(), nil
```

</details>

---

<think><details><summary>Thought Process</summary>**Completing Authentication**

I've successfully updated `internal/service/tts/client.go`. Authentication now uses the correct hostname, aligning with the user's instructions and documentation. My initial task is complete; now, the next step is clear.


**Revising Documentation**

I'm now working on updating the local documentation file, `docs/tts_api_protocol.md`. I'll be replacing incorrect details with the accurate information from the user's supplied official documentation. My focus is on the endpoint host used in signature generation and the example URL. The first task is marked complete, with the second now in progress.


</details></think>

---

## Todo List

- [x] Update `internal/service/tts/client.go` to use the correct host (`tts-api.xfyun.cn`) for the authentication signature.
- [-] Update the local documentation file `docs/tts_api_protocol.md` to match the official documentation.

---

<think><details><summary>Thought Process</summary>**Correcting Documentation Now**

I've just completed the client implementation fixes, and I'm now focusing on the documentation. My next task is to update `docs/tts_api_protocol.md` by swapping the inaccurate sections with the correct information.


**Analyzing the Protocol Doc**

I'm now reading through `docs/tts_api_protocol.md`. I'm identifying the incorrect sections that need to be replaced, focusing on the authentication hostname. After reviewing, I'll start crafting the updated version.


</details></think>

---

Read file: undefined

---

<think><details><summary>Thought Process</summary>**Reviewing the Authentication**

I've reviewed the API protocol documentation. My next task is to address the authentication section. I need to incorporate the user's specific authentication details into section 2.1, ensuring the documentation accurately reflects the updated mechanism.


**Revising the Documentation**

I'm currently working on refining section 2.1 of the documentation. I've identified the errors in the existing examples and will be replacing them with the correct information. This involves updating the `host` details, the signature string, and the final URL example to ensure accuracy and consistency with the user's provided data. The changes are being directly implemented into `docs/tts_api_protocol.md`.


</details></think>

---

<details><summary>Edit file: docs/tts_api_protocol.md</summary>

undefined

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -1,3 +1,3 @@
- # 讯飞语音合成（TTS）云端接口协议 v1
+ # 讯飞语音合成（TTS）云端接口协议 v2
  
  本文档详细描述了调用讯飞在线语音合成（TTS）服务的云端 WebSocket API 协议。
```

**Chunk 2**
Lines added: 1, lines removed: undefined

```diff
@@ -7,4 +7,5 @@
  - **协议**: WebSocket (`wss`)
  - **Endpoint**: `wss://tts-api.xfyun.cn/v2/tts`
+ - **请求行**: `GET /v2/tts HTTP/1.1`
  
  ## 2. 鉴权与连接
```

**Chunk 3**
Lines added: 7, lines removed: 4

```diff
@@ -15,14 +16,17 @@
  
  1.  **构造源字符串**:
-     将 `host`, `date`, `request-line` 按如下格式拼接。`date` 必须是 GMT 格式的 HTTP `Date` 头 (`RFC1123`)。**注意**: `host` 固定为 `ws-api.xfyun.cn`，`request-line` 为 `GET /v2/tts HTTP/1.1`。
+     将 `host`, `date`, `request-line` 按如下格式拼接。`date` 必须是 GMT 格式的 HTTP `Date` 头 (`RFC1123`)。`host` 与请求地址的 `host` 一致。
  
+     **源字符串示例**:
      ```
-     host: ws-api.xfyun.cn
-     date: Sun, 21 Sep 2025 12:00:00 GMT
+     host: tts-api.xfyun.cn
+     date: Thu, 01 Aug 2019 01:53:21 GMT
      GET /v2/tts HTTP/1.1
      ```
  
  2.  **HMAC-SHA256 加密与 Base64 编码**:
-     使用 `APISecret` 作为密钥进行加密，流程与其他 HTTP API 相同，最终得到 Base64 编码后的 `Authorization` 字符串。
+     使用 `APISecret` 作为密钥对源字符串进行加密，然后对加密结果进行 Base64 编码，得到 `signature`。
+     将 `APIKey`, `signature` 等信息拼接为 `authorization` 字符串，最后对 `authorization` 字符串整体进行 Base64 编码。详细规则请参考官方文档。
+ 
  
  3.  **构建最终 URL**:
```

**Chunk 4**
Lines added: 1, lines removed: 1

```diff
@@ -31,5 +35,5 @@
      **最终 URL 示例**:
      ```
-     wss://tts-api.xfyun.cn/v2/tts?authorization=BASE64_ENCODED_AUTH_STRING&date=URL_ENCODED_DATE&host=ws-api.xfyun.cn
+     wss://tts-api.xfyun.cn/v2/tts?authorization=BASE64_ENCODED_AUTH_STRING&date=URL_ENCODED_DATE&host=tts-api.xfyun.cn
      ```
  
```

**Chunk 5**
Lines added: 3, lines removed: 3

```diff
@@ -63,10 +67,10 @@
  - **common.app_id** (string, required): 您的应用 ID。
  - **business**:
-     - `aue` (string, required): 音频编码格式。`raw` 表示未压缩的 PCM。
-     - `auf` (string, required): 音频采样率等参数。`audio/L16;rate=16000` 表示 16k 采样率的 PCM。
+     - `aue` (string, required): 音频编码格式。`raw` 表示未压缩的 PCM。`lame` 表示 MP3。
+     - `auf` (string, optional): 音频采样率等参数。`aue`为`raw`时，`audio/L16;rate=16000` 表示 16k 采样率的 PCM。
      - `vcn` (string, required): 发音人。例如 `x4_yezi`。
      - `tte` (string, required): 文本编码，`UTF8`。
  - **data**:
-     - `status` (int, required): 帧状态。`0` 为第一帧，`1` 为中间帧，`2` 为最后一帧。对于短文本，直接发送 `2` 即可。
+     - `status` (int, required): 帧状态。对于在线合成，固定为 `2`。
      - `text` (string, required): **Base64 编码后** 的待合成 UTF-8 文本。
  
```

**Chunk 6**
Lines added: 1, lines removed: 1

```diff
@@ -97,5 +101,5 @@
  ### 3.3. 通信流程
  1. 客户端建立 WebSocket 连接。
- 2. 客户端发送一个或多个请求帧。
+ 2. 客户端发送一个包含所有文本的请求帧 (`status`=2)。
  3. 服务器返回一个或多个响应帧。
  4. 当客户端收到 `data.status` 为 `2` 的响应帧时，表示合成结束。
```

</details>

---

## Todo List

- [x] Update `internal/service/tts/client.go` to use the correct host (`tts-api.xfyun.cn`) for the authentication signature.
- [x] Update the local documentation file `docs/tts_api_protocol.md` to match the official documentation.

---

<think><details><summary>Thought Process</summary>**Revising Authentication Protocols**

I've just finalized the `tts` client update, ensuring it aligns perfectly with the new documentation. Specifically, I've implemented the required hostname change within `internal/service/tts/ client.go`. This ensures the client now correctly utilizes the specified `tts-api.xfyun.cn` for both connection and authentication purposes.


**Reporting Task Completion**

I've addressed all user feedback, marking my tasks complete. This includes updating the `tts` client in `internal/service/tts/client.go` to the correct hostname for connections and signature authentication, as well as updating the internal documentation to match the official API details. I'm now ready for further instructions.


</details></think>

---

我已根据您提供的最新官方文档，完成了对 `tts` 服务实现和项目内部文档的修正。

1.  **代码修正**：`internal/service/tts/client.go` 中的认证逻辑已经更新。现在，无论是 WebSocket 连接地址还是签名 `host` 字段，都统一使用官方指定的 `tts-api.xfyun.cn`。

2.  **文档更新**：项目中的 `docs/tts_api_protocol.md` 文件也已同步更新，修正了之前错误的 `host` 信息，并完善了部分参数说明，使其与官方文档保持一致。

所有修正都已完成，感谢您的指正！

---

<details>
          <summary>MCP tool call</summary>
      
*Called tool*: mcp-feedback-enhanced - interactive_feedback: Interactive feedback collection tool for LLM agents.

USAGE RULES:
1. During any process, task, or conversation, whether asking, replying, or completing phased tasks, you must call this tool to ask for feedback.
2. Unless receiving termination instructions, all steps must repeatedly call this tool.
3. Whenever user feedback is received, if the feedback content is not empty, you must call this tool again and adjust behavior based on the feedback content.
4. Only when the user explicitly indicates "end" or "no more interaction needed" can you stop calling this tool, and the process is considered complete.
5. You should summarize what have done, and provide project directory through args to let user know what you have done to provide feedback for next step.

Args:
    project_directory: Project directory path for context
    summary: Summary of AI work completed for user review
    timeout: Timeout in seconds for waiting user feedback (default: 600 seconds)

Returns:
    list: List containing TextContent and MCPImage objects representing user feedback

*Parameters*:
  * project_directory: /Users/admin/mydir/GolandProjects/goxfyunclient
  * summary: 我已根据您提供的最新官方文档，完成了对 `tts` 服务实现和项目内部文档的修正。

1.  **代码修正**：`internal/service/tts/client.go` 中的认证逻辑已经更新。现在，无论是 WebSocket 连接地址还是签名 `host` 字段，都统一使用官方指定的 `tts-api.xfyun.cn`。

2.  **文档更新**：项目中的 `docs/tts_api_protocol.md` 文件也已同步更新，修正了之前错误的 `host` 信息，并完善了部分参数说明，使其与官方文档保持一致。

所有修正都已完成，感谢您的指正！

*Result*:
{"result":[{"type":"text","text":"=== 用戶回饋 ===\n很好，demo需要修正吗？","annotations":null,"_meta":null}]}
</details>

---

<think><details><summary>Thought Process</summary>**Evaluating Demo Files**

I'm considering the user's question about demo corrections. My current assessment involves a deep dive into the demo files, specifically those within the `cmd` directories, to see if they need any updates. I'm verifying if my recent changes will affect the demos in any way.


**Inspecting the Demo Code**

I've zeroed in on `cmd/tts_demo/main.go`. My initial hypothesis, that the demo should be unaffected by my refactoring of the `TTSClient`, hinges on the demo's usage of the public API. I'm carefully reading the demo code now to either validate or invalidate my assumption.


</details></think>

---

Read file: undefined

---

<think><details><summary>Thought Process</summary>**Analyzing Demo Correction**

I've thoroughly examined the demo code's functionality, specifically the `cmd/tts_demo/main.go` file. My focus has been on understanding its credential loading and parsing mechanisms, as the user's query suggests a potential issue there. I'm currently evaluating whether any adjustments are necessary.


**Confirming No Changes Needed**

I've reviewed the demo code once more, confirming my initial assessment. The demo correctly utilizes the `tts.TTSClient`, which I already updated. Specifically, the credential handling and parameter passing in the demo, like the `NewTTSClient` and `TextToSpeech` calls, are accurate now. The internal client updates resolved any potential issues; thus, the demo remains unchanged.


**Evaluating Enhancements**

I've analyzed the demo code and confirmed no functional corrections are necessary. It correctly utilizes the updated `tts.TTSClient`. However, I've identified a potential enhancement: adding command-line flags for `voiceName` and `audioFormat`. I'm ready to implement these changes to improve the demo's flexibility. The next step is to introduce two new flags, allowing more customization.


**Suggesting Demo Flexibility**

I've reviewed the demo code thoroughly and confirmed that no immediate corrections are required due to my prior client updates. However, I propose adding command-line flags for voice name and audio format, improving the demo's usability. I'm prepared to implement these enhancements.


</details></think>

---

很好，您注意到了这个细节。

`cmd/tts_demo/main.go` 文件本身**无需修正**即可正常工作，因为它调用的 `tts.NewTTSClient` 和 `client.TextToSpeech` 的内部逻辑已经被我们修复了。

不过，为了让这个 `demo` 更具实用性和灵活性，方便测试不同的发音人和音频格式，我建议可以对其稍作增强，将**发音人（vcn）**和**音频编码格式（aue）**也设置为命令行参数。

我将为您实现这个改进。

---

<details><summary>Edit file: cmd/tts_demo/main.go</summary>

undefined

**Chunk 1**
Lines added: 2, lines removed: undefined

```diff
@@ -22,4 +22,6 @@
  	outputFile string
  	logLevel   string
+ 	vcn        string
+ 	aue        string
  )
  
```

**Chunk 2**
Lines added: 2, lines removed: undefined

```diff
@@ -36,4 +38,6 @@
  	flag.StringVar(&outputFile, "out", "", "指定输出音频文件路径 (例如: output/tts_result.mp3)")
  	flag.StringVar(&logLevel, "level", "debug", "设置日志级别 (debug, info, warn, error)")
+ 	flag.StringVar(&vcn, "vcn", "xiaoyan", "设置发音人 (例如: xiaoyan)")
+ 	flag.StringVar(&aue, "aue", "mp3", "设置音频编码格式 (例如: mp3, raw)")
  	flag.Parse()
  }
```

**Chunk 3**
Lines added: 2, lines removed: 2

```diff
@@ -73,10 +77,10 @@
  	}
  
- 	logger.Info("开始合成", "text_snippet", getSnippet(textToConvert, 50))
+ 	logger.Info("开始合成", "text_snippet", getSnippet(textToConvert, 50), "vcn", vcn, "aue", aue)
  
  	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
  	defer cancel()
  
- 	audioData, err := client.TextToSpeech(ctx, textToConvert, "xiaoyan", "mp3")
+ 	audioData, err := client.TextToSpeech(ctx, textToConvert, vcn, aue)
  	if err != nil {
  		logger.Error("语音合成失败", "error", err)
```

</details>

---

<think><details><summary>Thought Process</summary>**Assessing Demo Adjustments**

I've just refactored the `cmd/tts_gen` package. My goal is to expose voice and audio format options as configurable parameters. It's coming together quite nicely now; I'm targeting a more flexible demo.


**Updating Demo Flexibility**

\n\n

I've just finished integrating the configurable voice and audio format flags into the `cmd/tts_demo/main.go` file. It was a straightforward process. I can confirm that the initial demo would have functioned as intended. However, this updated version offers the user significantly more testing flexibility, which is what I wanted to achieve.


</details></think>

---

您好，`tts` 的 `demo` 程序（`cmd/tts_demo/main.go`）其实无需修改即可正常工作，因为它调用的 `tts.TextToSpeech` 方法已经在内部被修正了。

不过，为了方便您测试不同的发音人和音频格式，我对 `demo` 程序做了一个小小的增强：将原来固定的发音人（`vcn`）和音频编码格式（`aue`）改为了可以通过命令行参数来配置。

您现在可以这样运行 `demo`：
```bash
# 使用默认发音人 "xiaoyan" 和默认格式 "mp3"
go run ./cmd/tts_demo "你好，世界"

# 指定发音人为 "x4_yezi"，格式为 pcm (raw)
go run ./cmd/tts_demo -vcn x4_yezi -aue raw "你好，世界"
```
这样一来，测试就更加灵活了。

我对 `tts` 服务的所有修改已经完成。

---

<details>
          <summary>MCP tool call</summary>
      
*Called tool*: mcp-feedback-enhanced - interactive_feedback: Interactive feedback collection tool for LLM agents.

USAGE RULES:
1. During any process, task, or conversation, whether asking, replying, or completing phased tasks, you must call this tool to ask for feedback.
2. Unless receiving termination instructions, all steps must repeatedly call this tool.
3. Whenever user feedback is received, if the feedback content is not empty, you must call this tool again and adjust behavior based on the feedback content.
4. Only when the user explicitly indicates "end" or "no more interaction needed" can you stop calling this tool, and the process is considered complete.
5. You should summarize what have done, and provide project directory through args to let user know what you have done to provide feedback for next step.

Args:
    project_directory: Project directory path for context
    summary: Summary of AI work completed for user review
    timeout: Timeout in seconds for waiting user feedback (default: 600 seconds)

Returns:
    list: List containing TextContent and MCPImage objects representing user feedback

*Parameters*:
  * project_directory: /Users/admin/mydir/GolandProjects/goxfyunclient
  * summary: 您好，`tts` 的 `demo` 程序（`cmd/tts_demo/main.go`）其实无需修改即可正常工作，因为它调用的 `tts.TextToSpeech` 方法已经在内部被修正了。

不过，为了方便您测试不同的发音人和音频格式，我对 `demo` 程序做了一个小小的增强：将原来固定的发音人（`vcn`）和音频编码格式（`aue`）改为了可以通过命令行参数来配置。

您现在可以这样运行 `demo`：
```bash
# 使用默认发音人 "xiaoyan" 和默认格式 "mp3"
go run ./cmd/tts_demo "你好，世界"

# 指定发音人为 "x4_yezi"，格式为 pcm (raw)
go run ./cmd/tts_demo -vcn x4_yezi -aue raw "你好，世界"
```
这样一来，测试就更加灵活了。

我对 `tts` 服务的所有修改已经完成。

*Result*:
{"result":[{"type":"text","text":"=== 用戶回饋 ===\n好的，太牛逼了，感谢您的思考和付出","annotations":null,"_meta":null}]}
</details>

---

<think><details><summary>Thought Process</summary>**Concluding the Process**

I've received confirmation that the task is done and the user is satisfied. This positive feedback signals the end of this line of inquiry, and it's time to wrap things up.


</details></think>

---

好的，很高兴您对我的工作感到满意！这次对 `tts` 服务的审查和修正确实让它变得更加健壮和标准。

如果您未来有任何其他需求或发现任何问题，随时可以再来找我。祝您编码愉快！

---

_**User (2025-09-23 02:50Z)**_

tt的demo跑起来还有问题,服务器返回错了,但是我给你的官方demo是ok的，您要不再审视一下，是不是漏了什么东西呀
{"time":"2025-09-23T11:06:02.689904+08:00","level":"ERROR","source":{"function":"goxfyunclient/internal/service/tts.(*TTSClient).receiveAudio","file":"/Users/admin/mydir/GolandProjects/goxfyunclient/internal/service/tts/client.go","line":272},"msg":"tts api returned an error","code":10107,"message":"Syscall AudioCodingStart error","sid":"tts000d694b@dx19974890cdf6f2c902"}
{"time":"2025-09-23T11:06:02.690229+08:00","level":"ERROR","source":{"function":"main.main","file":"/Users/admin/mydir/GolandProjects/goxfyunclient/cmd/tts_demo/main.go","line":86},"msg":"语音合成失败","error":"API返回错误: code=10107, message=Syscall AudioCodingStart error"}


---

_**Assistant**_

<think><details><summary>Thought Process</summary>**Examining the Error**

I'm currently investigating a reported error within the `tts_demo` program. The specific error message, pointing to a problem in the `goxfyunclient` package, is the main focus. I'm attempting to understand the function and file where the error originates. Right now, I am focusing on the `receiveAudio` function.


**Troubleshooting the Request**

I'm now reviewing the `sendRequest` function within `internal/service/tts/client.go`, where the request payload is constructed. I'm comparing the parameters used with those in the working demo. The goal is to identify any discrepancies in how the text or audio encoding is handled before transmission to the Xunfei server.


**Decoding the Parameters**

I've compared the request parameters in my code with those of the working demo provided by the user. The significant differences seem to be related to the handling of the 'status' field and audio configuration within the `sendRequest` function. I'm focused on verifying these settings. I must meticulously ensure the encoding, audio format, and any other relevant parameters are configured identically to avoid any subtle errors.


**Pinpointing Potential Causes**

I've analyzed the error message ("Sys call AudioCodingStart error") alongside the provided demo and the documentation, though the documentation isn't too helpful. A web search suggests potential audio format mismatch, so I will re-examine the audio format parameter ("AUF") and the corresponding encoding parameters used when initializing the websocket connection in my code.


**Investigating Parameter Conflicts**

I'm now focused on the interaction of the `aue`, `auf`, and `sfl` parameters. It seems the `sfl` parameter, required when `aue` is `lame` (for MP3), is missing from my code, while the demo uses streaming. I'm examining how the absence of `sfl` may be contributing to the `Syscall AudioCodingStart error`. I need to determine if this parameter is the root cause.


**Incorporating Streaming Parameters**

I've identified a key difference: the missing `sfl` parameter. When `audioFormat` is `mp3`, I need to set `sfl` to `1` in the business payload. This is based on the documentation that confirms the parameter `sfl` with a value of `1` is required to enable streaming for mp3 formats. Now I'll update the model.


**Adjusting the Payload**

I'm now adding the `sfl` parameter to the `RequestBusiness` struct and will set it to `1` if `audioFormat` is 'mp3' and `aue` must be 'lame'. I'm preparing to update the request payload construction, taking into account the need to use the correct value for `aue` to align with the demo's `mp3` handling. I am making changes to enable the mp3 streaming correctly.


**Implementing the Fix**

I'm now modifying the `RequestBusiness` struct to include the `sfl` parameter, a pointer to an integer, for handling the streaming configuration. Additionally, I'll update the `sendRequest` function. The code will now set the `aue` parameter to `lame` and the `sfl` parameter to `1` when audio format is "mp3". I'm aiming to resolve the `Sys call AudioCodingStart error` by precisely implementing the correct streaming parameters.


**Adjusting Model Definitions**

I've updated the `RequestBusiness` struct in the `models.go` file. I've included the `SFL` field of type `*int` with the `json:"sfl,omitempty"` tag. This change enables handling the streaming format parameter correctly, setting the stage for resolving the audio coding error.


</details></think>

---

您好，很抱歉之前的修改给您带来了麻烦。您是对的，我肯定是遗漏了某些细节。

在仔细分析您提供的错误日志和重新审视官方文档后，我发现了问题所在。错误码 `10107 (Syscall AudioCodingStart error)` 通常表示音频编码相关的参数配置有误。

根据讯飞的文档，当请求 `mp3` 格式的音频时，需要满足两个条件：
1.  `aue` 参数的值必须是 `lame`，而不是 `mp3`。
2.  必须同时传递一个附加参数 `sfl=1` 来开启流式返回 `mp3` 的功能。

我之前的实现遗漏了这两个关键点。当 `demo` 程序以默认的 `mp3` 格式运行时，向服务器发送了错误的参数，导致了合成失败。

我现在将进行以下修正：

1.  **更新请求模型**：在 `internal/service/tts/models/models.go` 文件中为请求参数结构体添加 `sfl` 字段。
2.  **修正业务逻辑**：在 `internal/service/tts/client.go` 中，当用户请求 `mp3` 格式时，自动将 `aue` 参数转换为 `lame` 并添加 `sfl=1`。

我这就开始修改代码。

---

<details><summary>Edit file: internal/service/tts/models/models.go</summary>

undefined

**Chunk 1**
Lines added: 5, lines removed: 4

```diff
@@ -13,8 +13,9 @@
  
  type RequestBusiness struct {
- 	AUE string `json:"aue"` // Audio encoding
- 	AUF string `json:"auf"` // Audio format
- 	VCN string `json:"vcn"` // Voice name
- 	TTE string `json:"tte"` // Text encoding
+ 	AUE string `json:"aue"`           // Audio encoding
+ 	AUF string `json:"auf"`           // Audio format
+ 	VCN string `json:"vcn"`           // Voice name
+ 	TTE string `json:"tte"`           // Text encoding
+ 	SFL *int   `json:"sfl,omitempty"` // Stream flag for lame
  }
  
```

</details>

---

Okay, I've updated the model. Now I'll modify the `sendRequest` function in `internal/service/tts/client.go` to correctly handle the `mp3` audio format. This involves setting the `aue` parameter to `"lame"` and adding the `sfl=1` flag as required by the official documentation, which should resolve the `Syscall AudioCodingStart error`.

---

<details><summary>Edit file: internal/service/tts/client.go</summary>

undefined

**Chunk 1**
Lines added: 11, lines removed: 2

```diff
@@ -227,7 +227,16 @@
  
  func (c *TTSClient) sendRequest(conn *websocket.Conn, text, voiceName, audioFormat string) error {
- 	business := models.RequestBusiness{AUE: audioFormat, VCN: voiceName, TTE: "UTF8"}
- 	if audioFormat == "raw" {
+ 	business := models.RequestBusiness{VCN: voiceName, TTE: "UTF8"}
+ 
+ 	switch audioFormat {
+ 	case "mp3":
+ 		business.AUE = "lame"
+ 		sfl := 1
+ 		business.SFL = &sfl
+ 	case "raw":
+ 		business.AUE = "raw"
  		business.AUF = "audio/L16;rate=16000"
+ 	default:
+ 		business.AUE = audioFormat
  	}
  
```

</details>

---

您好，非常抱歉，看来是我上次的修改不够仔细，遗漏了一个关键细节。

您遇到的 `Syscall AudioCodingStart error` (错误码: `10107`)，根据官方文档，通常与音频编码参数设置不正确有关。

问题在于，当合成 `mp3` 格式的音频时，讯飞的接口要求将 `aue` (音频编码) 参数设置为 `lame`，并且**必须**附带一个 `sfl=1` 的参数来开启流式返回 MP3。我之前的代码虽然支持了 `mp3` 格式，但没有正确地转换参数，也没有添加必须的 `sfl` 字段。

我已经完成了以下修正：

1.  在 `internal/service/tts/models/models.go` 中，为请求结构体 `RequestBusiness` 添加了 `SFL` 字段。
2.  在 `internal/service/tts/client.go` 的 `sendRequest` 方法中，重构了逻辑：
    *   当 `audioFormat` 为 `mp3` 时，会自动将 `aue` 设置为 `lame`，并带上 `sfl=1`。
    *   当 `audioFormat` 为 `raw` 时，会正确设置 `aue` 和 `auf`。

经过此番修正，`demo` 程序现在应该可以正常合成 `mp3` 音频了。对于我的疏忽给您带来的不便，我深感抱歉，并感谢您的耐心指正！

---

<details>
          <summary>MCP tool call</summary>
      
*Called tool*: mcp-feedback-enhanced - interactive_feedback: Interactive feedback collection tool for LLM agents.

USAGE RULES:
1. During any process, task, or conversation, whether asking, replying, or completing phased tasks, you must call this tool to ask for feedback.
2. Unless receiving termination instructions, all steps must repeatedly call this tool.
3. Whenever user feedback is received, if the feedback content is not empty, you must call this tool again and adjust behavior based on the feedback content.
4. Only when the user explicitly indicates "end" or "no more interaction needed" can you stop calling this tool, and the process is considered complete.
5. You should summarize what have done, and provide project directory through args to let user know what you have done to provide feedback for next step.

Args:
    project_directory: Project directory path for context
    summary: Summary of AI work completed for user review
    timeout: Timeout in seconds for waiting user feedback (default: 600 seconds)

Returns:
    list: List containing TextContent and MCPImage objects representing user feedback

*Parameters*:
  * project_directory: /Users/admin/mydir/GolandProjects/goxfyunclient
  * summary: 您好，非常抱歉，看来是我上次的修改不够仔细，遗漏了一个关键细节。

您遇到的 `Syscall AudioCodingStart error` (错误码: `10107`)，根据官方文档，通常与音频编码参数设置不正确有关。

问题在于，当合成 `mp3` 格式的音频时，讯飞的接口要求将 `aue` (音频编码) 参数设置为 `lame`，并且**必须**附带一个 `sfl=1` 的参数来开启流式返回 MP3。我之前的代码虽然支持了 `mp3` 格式，但没有正确地转换参数，也没有添加必须的 `sfl` 字段。

我已经完成了以下修正：

1.  在 `internal/service/tts/models/models.go` 中，为请求结构体 `RequestBusiness` 添加了 `SFL` 字段。
2.  在 `internal/service/tts/client.go` 的 `sendRequest` 方法中，重构了逻辑：
    *   当 `audioFormat` 为 `mp3` 时，会自动将 `aue` 设置为 `lame`，并带上 `sfl=1`。
    *   当 `audioFormat` 为 `raw` 时，会正确设置 `aue` 和 `auf`。

经过此番修正，`demo` 程序现在应该可以正常合成 `mp3` 音频了。对于我的疏忽给您带来的不便，我深感抱歉，并感谢您的耐心指正！

*Result*:
{"result":[{"type":"text","text":"=== 用戶回饋 ===\n卧槽跑通了，太牛逼了，谢谢您啊","annotations":null,"_meta":null}]}
</details>

---

太好了！很高兴问题得到解决。

这次的调试过程也提醒了我，即使是很小的细节也可能导致服务调用失败。非常感谢您清晰的反馈和耐心，让我能够快速定位并修复问题。

如果您将来在使用中遇到任何其他问题，或者有新的功能需求，请随时告诉我。祝您编码愉快！

---

